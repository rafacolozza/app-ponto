import re
from datetime import datetime
from io import BytesIO

import pdfplumber
import pandas as pd

# Regex para linhas de dia e horários
# Exemplo:
# 22/10/2025 - qua. 11:56 14:04 15:07 21:50 ...
RE_LINHA_DIA = re.compile(r"^(\d{2}/\d{2}/\d{4})\s*-\s*([^\s]+)\s*(.*)$")
RE_HORARIO = re.compile(r"\b\d{2}:\d{2}\b")

# Palavras que indicam dia sem trabalho efetivo
PALAVRAS_BLOQUEIO = [
    "FÉRIAS",
    "FERIAS",
    "FALTA",
    "ABONO APROVADO",
    "FOLGA",
    "FERIADO",
]

# Motivos de abono para detalhar em colunas
MOTIVOS_ABONO = ["Atestado", "Feriado", "Folga"]


def extrair_nome(texto_pagina: str) -> str:
    """
    Procura 'Nome:' na linha.
    - Se o nome estiver na mesma linha (ex: 'Nome: Fulano da Silva'), usa essa parte.
    - Se a linha for só 'Nome:', pega a próxima linha.
    """
    linhas = texto_pagina.splitlines()
    for i, l in enumerate(linhas):
        if "Nome:" in l:
            parte = l.split("Nome:", 1)[-1].strip()
            if parte:
                return parte
            if i + 1 < len(linhas):
                return linhas[i + 1].strip()
    return "DESCONHECIDO"


def extrair_centro_custo(texto_pagina: str) -> str:
    """
    Pega o trecho após 'Centro de Custo:'.
    Ex:
    Centro de Custo: 62.938.774/0001-15 - 01 - Colégio Miguel de Cervantes
    """
    linhas = texto_pagina.splitlines()
    for l in linhas:
        if "Centro de Custo:" in l:
            return l.split("Centro de Custo:", 1)[-1].strip()
    return "NÃO ENCONTRADO"


def linha_tem_trabalho(linha: str) -> bool:
    """
    Retorna True se a linha representa um dia efetivamente trabalhado.

    Regras:
    - Só considera linhas que começam com data (dd/mm/aaaa).
    - Ignora domingos.
    - Ignora linhas com palavras de bloqueio (Férias, Falta, Abono Aprovado, Folga, Feriado…).
    - Pega apenas os primeiros horários (batidas e colunas principais),
      ignorando saldos finais (ex: 62:08, 67:29).
    """

    # Normaliza espaços
    linha_norm = " ".join(linha.split())

    # Tem que ser linha de dia: precisa bater o regex de data no início
    m = RE_LINHA_DIA.match(linha_norm)
    if not m:
        return False

    texto_upper = linha_norm.upper()

    # Domingo nunca conta como dia trabalhado
    if "DOMINGO" in texto_upper:
        return False

    # Palavras que representam dia sem trabalho
    if any(p in texto_upper for p in PALAVRAS_BLOQUEIO):
        return False

    # Pega os horários da linha (já normalizada)
    horarios = RE_HORARIO.findall(linha_norm)
    if not horarios:
        return False

    # Ignora possíveis saldos no fim (62:08, 67:29...), usando só as colunas principais
    # 10 campos é um limite seguro: Ent1, Sai1, Ent2, Sai2, Normal, D.F., Crédito,
    # Intervalo, Interjornada, H.E.1.
    horarios_principais = horarios[:10] if len(horarios) > 10 else horarios

    # Se algum desses horários principais for diferente de 00:00, consideramos trabalhado
    return any(h != "00:00" for h in horarios_principais)


def extrair_datas_periodo(texto_pagina: str):
    """
    Lê todas as datas da página e retorna (data mínima, data máxima)
    """
    datas = []
    for linha in texto_pagina.splitlines():
        linha_limpa = " ".join(linha.split())
        m = RE_LINHA_DIA.match(linha_limpa)
        if m:
            data_str = m.group(1)
            try:
                d = datetime.strptime(data_str, "%d/%m/%Y").date()
                datas.append(d)
            except ValueError:
                pass

    if not datas:
        return None, None

    return min(datas), max(datas)


def processar_espelho_ponto_bytes(pdf_bytes: bytes) -> pd.DataFrame:
    """
    Processa o PDF e retorna 1 linha por funcionário com:

    - Centro de Custo
    - Nome
    - Periodo_Inicio / Periodo_Fim
    - Dias_trabalhados
    - Dias_abono
    - Dias_ferias
    - Dias_falta
    - Abono_Atestado / Abono_Feriado / Abono_Folga
    """
    registros = []

    with pdfplumber.open(BytesIO(pdf_bytes)) as pdf:
        for page_num, page in enumerate(pdf.pages, start=1):
            texto = page.extract_text() or ""
            if not texto.strip():
                continue

            nome = extrair_nome(texto)
            centro_custo = extrair_centro_custo(texto)
            data_inicio, data_fim = extrair_datas_periodo(texto)

            dias_trabalhados = 0
            dias_abono = 0
            dias_ferias = 0
            dias_falta = 0
            motivo_counts = {m: 0 for m in MOTIVOS_ABONO}

            for linha in texto.splitlines():
                linha_norm = " ".join(linha.split())
                linha_upper = linha_norm.upper()

                # Conta dia trabalhado
                if linha_tem_trabalho(linha_norm):
                    dias_trabalhados += 1

                # Só analisamos linhas que realmente são de dia (começam com data)
                m = RE_LINHA_DIA.match(linha_norm)
                if not m:
                    continue

                # Classificações por tipo de dia
                if "ABONO APROVADO" in linha_upper:
                    dias_abono += 1
                    for mot in MOTIVOS_ABONO:
                        if mot.upper() in linha_upper:
                            motivo_counts[mot] += 1

                if "FÉRIAS" in linha_upper or "FERIAS" in linha_upper:
                    dias_ferias += 1

                if "FALTA" in linha_upper:
                    dias_falta += 1

            if nome != "DESCONHECIDO" and data_inicio and data_fim:
                row = {
                    "Centro de Custo": centro_custo,
                    "Nome": nome,
                    "Periodo_Inicio": data_inicio.strftime("%d/%m/%Y"),
                    "Periodo_Fim": data_fim.strftime("%d/%m/%Y"),
                    "Dias_trabalhados": dias_trabalhados,
                    "Dias_abono": dias_abono,
                    "Dias_ferias": dias_ferias,
                    "Dias_falta": dias_falta,
                }

                # adiciona colunas por motivo de abono
                for mot in MOTIVOS_ABONO:
                    row[f"Abono_{mot}"] = motivo_counts[mot]

                registros.append(row)

    df = pd.DataFrame(registros)
    if not df.empty:
        df = df.sort_values(["Centro de Custo", "Nome"])

    return df
